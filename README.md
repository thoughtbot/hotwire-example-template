# Hotwire: Server-rendered live previews

[![Deploy to Heroku](https://www.herokucdn.com/deploy/button.png)][heroku-deploy-app]

[heroku-deploy-app]: https://heroku.com/deploy?template=https://github.com/thoughtbot/hotwire-example-template/tree/hotwire-example-live-preview

The upcoming [Rails 7][] release will be notable for numerous reasons.
One of the more remarkable being the deprecation and removal of Rails
UJS, and the introduction of [Hotwire][] as Rails' [default JavaScript
framework][].

Let's learn more about how Hotwire fits into Rails by building an
Article drafting experience that provides end-users with a preview of
their final version as they type!

We'll start with an out-of-the-box Rails installation that utilizes
Turbo Drive, Turbo Streams, and Stimulus to then progressively enhance
concepts and tools that are built directly into browsers. Plus, it'll
degrade gracefully when JavaScript is unavailable!

The code samples contained within omit the majority of the application's
setup. While reading, know that the bulk of the application's code was
generated by a `rails new` command

The rest of the source code from this article can be found [on
GitHub][].

[Hotwire]: https://hotwired.dev
[Rails 7]: https://edgeguides.rubyonrails.org/7_0_release_notes.html
[default JavaScript framework]: https://github.com/rails/rails/pull/42999
[on GitHub]: https://github.com/thoughtbot/hotwire-example-template/commits/hotwire-example-live-preview

## Drafting Articles

We'll start by using Rails `model` generator to create some `Article`
[scaffolding][] code to serve as a starting point for our extensions and
customizations:

```sh
bin/rails generate scaffold Article content:text
bin/rails db:migrate
```

We won't be making any changes to the vast majority of the generated code, but
there are two view partials that will be changed the most throughout the rest of
the article. To have context for those changes, it's worth becoming familiar
with them before we get started: `app/views/articles/_form.html.erb` and
`app/views/articles/_article.html.erb`.

The `articles/form` partial renders a single `<textarea>` field for our
`Article` model's `content`, along with an `<input type="submit">`
element:

```erb
<%= form_with(model: article) do |form| %>
  <% if article.errors.any? %>
    <div id="error_explanation">
      <h2><%= pluralize(article.errors.count, "error") %> prohibited this article from being saved:</h2>

      <ul>
        <% article.errors.each do |error| %>
          <li><%= error.full_message %></li>
        <% end %>
      </ul>
    </div>
  <% end %>

  <div class="field">
    <%= form.label :content %>
    <%= form.text_area :content %>
  </div>

  <div class="actions">
    <%= form.submit %>
  </div>
<% end %>
```

Similarly, the `articles/article` partial renders the value of the
`content` as plain text:

```erb
<div id="<%= dom_id article %>" class="scaffold_record">
  <p>
    <strong>Content:</strong>
    <%= article.content %>
  </p>

  <p>
    <%= link_to "Show this article", article %>
  </p>
</div>
```

The rest of the generated code serves as the foundation for creating,
reading, updating, and destroying `Article` instances. While it's
crucial, they're implementation details that we can ignore for the sake
of this example.

[scaffolding]: https://edgeguides.rubyonrails.org/getting_started.html#mvc-and-you-generating-a-model
